```
+++ 
author = "kmplex" 
title = "unit testing 6장" 
date = "2022-02-02" 
description = "unit testing 2부 6장"  
series = ["unit testing"] 
categories = ["dev","test"] 
+++
```

[Unit Testing](http://www.yes24.com/Product/Goods/104084175)를 읽고 짤게 정리한 내용입니다.

## 2부 개발자에게 도움이 되는 테스트 만들기 

## 6장. 단위 테스트 스타일 


#### 1. 출력 기반 테스트 스타일

SUT 에 입력을 넣고, 출력을 검증하는 스타일로, 전역 / 내부 상태를 변경하지 않는 코드에만 적용 가능하다.
(SideEffect 가 없어야한다.)

#### 2. 상태 기반 테스트 스타일

함수를 호출 후, System 의 상태를 확인한다.
여기서 상태란, SUT / SUT 협력자 / 외부 의존성의 상태를 의미한다.

#### 3. 통신 기반 테스트 스타일 

Mock 을 사용해 SUT 와 협력자간의 통신을 검증한다.

단위 테스트에는 위처럼 3가지 스타일이 있으며, 하나의 테스트에 복수개(1~3개)를 사용 할 수 있다.

`고전파`는 통신 기반 테스트 보다, 상태 기반을 선호하며, `런던파`는 상태 기반보다 통신 기반 테스트를 선호한다.


#### 4대 요소와 스타일 비교

1. 회귀방지 및 피드백 속도 

회귀 방지는 테스트 실행량 / 복잡도 / 도메인 유의성으로 결정되므로, 스타일에 따른 차이가 없음.
피드백 속도 또한 차이가 미미함.

2. 리팩터링 내성 측면 

`리팩터링 중 발생하는 거짓 양성 수`

출력기반은 리팩터링 내성 측면에서 가장 우수하며, 상태기반은 구현 세부 사항과 결합 가능성이 높아 거짓 양성이 되기 쉽다.
통신 기반은 가장 취약한데, 상호 작용의 부작용이 외부에 보이는 경우에만 사용해야한다.


> 단 테스트 스타일에 상관 없이, 캡슐화를 잘 지키고 식별할 수 있는 동작에만 결합하면, 세부 사항의 결합을 최소로 줄일 수 있다. 
> (테스트 스타일에 따라 필요한 노력이 다르다.)


3. 유지보수성

- Test 를 이해하기 쉬운가 ?
- Test 를 실행하기 쉬운가 ?

Test가 크면 유지보수가 쉽지 않으며, 외부 의존성을 직접 연결하면 추가 시간이 소요되므로, 유지보수가 어렵다.

출력 기반은 상태를 바꾸지 않아, 이해하기 쉬우며 비교적 짧음
상태기반은 상태를 검증하기 때문에 출력 기반보다 어려움
통신기반은 mock chain이 있을 경우, Test 가 커지며 유지보수가 더 어려워지는 경향이 있다.

> 결론 

회귀 방지와 피드백 속도는 큰 차이가 없으나, 리팩터링 내성 / 유지보수성 에서는 출력 기반이 가장 우수한걸 알 수 있음
즉, 상태 / 통신기반을 출력 기반으로 바꾸는 노력이 필요하다.


또한 함수형 아키텍처 / 출력 기반 테스트를 사용 할 경우, 
시스템 성능 및 코드 량이 많아 질 수 있는데, 적당히 타협하여 사용해야한다.

> 모든 상황에서 출력 기반 테스트가 정답은 아니며, 상태 / 통신 기반을 섞어서 쓸 수 있다.

#### 함수형 프로그래밍 

숨은 입출력이 없는 함수로, 모든 입출력을 메서드 시그니처에 명시한다.
또한 멱등성이 보장되어야하며, 참조 투명성을 갖고 있어야한다.

> 참조 투명성이란, 함수가 외부 영향을 받지 않는 것으로, 표현식을 결과로 대체해도 프로그램이 지장이 없는 경우, 참조 투명성을 갖고 있다고 표현한다.

`숨은 입출력`이 있는 함수는 가독성이 떨어지며, Test 를 더 어렵게한다. 

> 숨은 입출력 유형

- SideEffect
- Exception
시그니처에 정의 되지 않은 출력(예외)으로, 어느 stack 에서든 발생 할 수 있다.
- 내/외부 상태 참조
DB 질의 및 비공개 변경가능 필드 참조하는 경우이다.

`함수형 프로그래밍`의 목표는 부작용을 완전히 제거하는게 아니라, 비즈니스 로직을 처리하는 코드 와 부작용을 일으키는 코드를 분리하는 것이다.

`비즈니스 로직`은 결정을 내리는 코드로, 함수형 코어 라고 말하며,
`부작용을 일으키는 코드`는 결정을 DB/Message Bus 등으로 변환하는 코드로, 가변 셸 이라 말한다.

`가변셸`이 입력을 받아, `함수형 코어`가 결정을 생성하고, 다시 셸이 결정을 부작용으로 반환하는 구조이다.

> 함수형 코어에 의사결정 코드를 몰아두고, 출력 기반 Test 를 두루 작성하며, 가변 셸 부분은 통합 테스트로 다룬다.

(개인 생각) 가변셸 부분에 로직이 많이 없을 경우, 통합테스트로 퉁칠 수 있을거 같음 (Application / Presentation Layer 도 퉁칠 수 있지 않을까?)

#### 함수형과 육각형 아키텍처 비교 

`공통점`

- 관심사 분리라는 아이디어 기반
- 의존성간의 단방향 흐름

`차이점`

- 부작용에 대한 처리
함수형 => 모든 부작용을 가변 셸에 담아냄 
육갹형 => 부작용을 도메인 계층에 제한한다. (상태를 들고 있는다.)

