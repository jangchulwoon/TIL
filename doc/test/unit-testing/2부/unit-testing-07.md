```
+++ 
author = "kmplex" 
title = "unit testing 7장" 
date = "2022-02-03" 
description = "unit testing 2부 7장"  
series = ["unit testing"] 
categories = ["dev","test"] 
+++
```

[Unit Testing](http://www.yes24.com/Product/Goods/104084175)를 읽고 짤게 정리한 내용입니다.

## 2부 개발자에게 도움이 되는 테스트 만들기 

## 7장. 가치 있는 단위 테스트를 위한 리팩터링 

#### 리팩터링할 코드 식별하기

테스트 코드와 제품 코드는 본질 적으로 관련되어 있기에, 기반 코드를 리팩터링하지 않고서는, 테스트 스위트를 크게 개선할 수 없다.
이번 절에서는 리팩터링 방향을 설명하고자, 코드를 네 가지 유형으로 분류하는 방법을 소개한다.

제품 코드는 2차원으로 분류할 수 있다.

- 복잡도 / 도메인 유의성
- 협력자 수

복잡도는 `1 + 분기점 수` 로 계산된다.
도메인 유의성은 코드가 도메인에 얼마나 의미있는가를 나타낸다.
도메인 계층의 코드는 유의성이 높으나, 유틸리티 코드는 유의하지 않다.

복잡한 코드와 도메인 유의성을 갖는 코드는 회귀 방지에 뛰어나기에, 단위 테스트에서 가장 이롭다.

> `복잡한 코드`는 도메인 유의성이 없더라도 테스트 할만하며, 도메인 코드는 복잡하지 않아도, 테스트 할 만하다. 

이 두 지표는 독립적으로, 복잡도가 낮으나, 도메인에 중요한 로직이라면 테스트가 중요해진다.

> 둘 중 하나의 지표라도 높다면, 테스트 할만 하다.

협력자 수는 가변 의존성이나 프로세스 외부 의존성을 의미한다.
협력자가 많은 코드는 테스트 비용이 많이 드는데, 협력자가 많을 수록 테스트가 커지기때문이다. (유지보수성)

> 협력은 domain -> application 으로 향하면 안되며, mock은 application 경계를 넘는 경우에만 사용해야한다.

![test-pyramid](07-01.jpg)

- 도메인 모델과 알고리즘 

회귀 방지가 뛰어나며, 협력자가 거의 없어 유지비가 낮으므로, 단위 테스트에 가장 이롭다.

> 코드가 중요하거나 / 복잡할 수록 협력자는 적어야한다.

- 간단한 코드

테스트할 필요가 없는 부분이다. 

- 컨트롤러

포괄적인 통합테스트의 일부로 간단히 테스트 할 수 있다. 

> 뒷장에 나온다는데, 어떤식으로 설명할지 기대됨

- 지나치게 복잡한 코드

많은 사람들이 단위 테스트로 어려움을 겪는 주요 원인 중 하나, 이 장에서는 해당 부분의 처리에 대해 고민한다.
일반적으로 알고리즘 / 컨트롤러라는 두 부분으로 나눠해결한다.

지나치게 복잡한 코드를 피하고, 도메인 모델과 알고리즘만 단위 테스트 하는 것이 매우 가치 있고, 유지 보수가 쉬운 테스트 스위트로 가는 길이다.
coverage 100%를 목표로 하지마라 ! 목표는 프로젝트 가치를 높이는 테스트 스위트 구성으로, 다른 테스트를 리팩터링 하거나 제거해라.

## 복잡한 코드를 제거하기

#### 험블 객체 패턴을 사용해 지나치게 복잡한 코드 분할하기

지나치게 복잡한 코드를 쪼개기 위해, 험블 객체 패턴을 사용하라.
험블 객체 패턴이란, Test 하기 어려운 로직을 Test 하기 쉬운(Humble) 부분으로 옮기는 패턴이다.



