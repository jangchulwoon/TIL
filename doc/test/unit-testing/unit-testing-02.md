```
+++ 
author = "kmplex" 
title = "unit testing (2-1)" 
date = "2022-01-15" 
description = "unit testing 2부 4장"  
series = ["unit testing"] 
categories = ["dev","test"] 
+++
```

[Unit Testing](http://www.yes24.com/Product/Goods/104084175)를 읽고 짤게 정리한 내용입니다.

## 2부 개발자에게 도움이 되는 테스트 만들기 

#### 4장. 좋은 단위 테스트의 4대 요소

1. 회귀 방지
2. 빠른 피드백 
3. 리팩터링 내성 
4. 유지 보수성

#### 1. 회귀 방지 

코드를 수정한 후, 기능이 의도한 대로 동작하는가를 확인한다.

> 코드를 수정한 후, 기능이 의도한 대로 작동하지 않는 경우를 회귀라 한다.

코드는 자산이 아닌, 책임의 성격을 띄는데, 코드 베이스가 커질수록 잠재적인 버그에 더 많이 노출되기 때문이다.
이러한 이유로, 소프트웨어가 지속 / 향상되기 위해선 회귀에 대한 효과적인 보호가 필요하다.

회귀 방지의 지표는 아래와 같다.

- 테스트 중 실행되는 코드의 양 
- 코드 복잡도 
- 코드의 도메인 유의성 

회귀 방지 관점에서, 보일러 플레이트 코드보다, 도메인 코드를 확인하는게 더 중요하며, Framework 코드등 개발자가 작성하지 않은 외부 영역의 테스트도 필요하다.

> 회귀 방지 지표를 극대화 하려면, 테스트가 가능한 많은 코드를 실행하는 것을 목표로 해야한다.

#### 2. 리팩터링 내성 

테스트가 실패하지 않고, 기본 Application Code 를 리팩터링 할 수 있는지에 대한 척도이다.
기반 코드를 수정했을 때 기능에는 변화가 없지만, Test 가 깨지는 경우를 `거짓 양성`이라한다.
거짓 양성은 허위 경보로, 지속가능한 성장을 막는다. 

테스트가 `지속 가능한 성장`을 하기위해선회귀 없이 주기적으로 / 자유로운 리팩터링이 가능해야한다.

> 테스트의 목적은 지속성 / 향상성이다.

거짓 양성은 이를 방해하는데, `1.` 타당한 이유없이 테스트가 실패하며 `2.` 허위 경보를 발생 시켜, 테스트를 믿을 만한 안정망으로 인식하지 않는다.


#### 2.1 무엇이 거짓 양성의 원인인가 ? 

거짓 양성은 테스트 구성 방식과 직접적인 관련이 있는데, SUT 와 구현 세부사항이 많이 결합할수록 허위 경보가 더 많이 생긴다.    
즉, 테스트에서 구현 세부사항을 분리시켜야한다. 테스트를 통해 SUT가 제공하는 최종 결과를 검증하는지 확인해야한다.


```kotlin
interface IRenderer {
    fun render(): String
}

class MessageRenderer {
    val subRenderers: MutableList<IRenderer> = mutableListOf()

    init {
        subRenderers.add(HeaderRenderer())
    }

    fun render(): String = subRenderers.joinToString("\n") { it.render() }
}

class HeaderRenderer : IRenderer {
    override fun render(): String = "header"
}
```

리팩터링은 Application의 식별할 수 있는 동작에 영향을 주지 않으면서, 구현을 변경하는 것이다.   
위 테스트는 하위 랜더링 클래스의 구성을 변경할 경우 응답에 상관 없이 깨지며, 리팩터링 내성이 없는 TC이다.

> 식별할 수 있는 동작을 고려하지 않고, 구현만 고집할 경우 깨지기 쉬운 TC가 된다.

#### 2.2 구현 세부 사항 대신 최종 결과를 목표로 하기

거짓 양성을 없애기 위해선, 구현 세부사항과 테스트간 결합도를 낮춰야한다. 즉, 최종 결과에 초점을 맞춰 TC를 작성해야한다.
`MessageRenderer` 를 블랙박스로 취급하고, 식별 할 수 있는 동작에만 신경을 써야한다.

#### 2.3 테스트 정확도 극대화

코드 정확도와 테스트 결과에 대해서는 4가지 결과가 있을 수 있다.

|-|기능 작동 | 기능 고장 |
|------|---|---|
|테스트 통과|올바른 추론| 거짓 음성 (회귀 방지)|
|테스트 실패|거짓 양성| 올바른 추론|

테스트가 통과하고, 기본 기능이 의도한대로 동작하는 상황은 올바른 추론이다.
마찬가지로, 기능이 고장나서 테스트가 실패하는 상황도 올바른 추론이다.

그러나, 기능이 고장 났을 떄, 테스트가 성공하면 `거짓 음성` 으로 회귀 방지가 되지 않는다.
또한 기능이 올바르지만, 테스트가 실패할 경우엔 `거짓 양성` 으로 리팩터링 내성이 되지 않는다.

테스트의 정확도를 극대화 시키기 위해, 이러한 거짓 음성 / 거짓 양성을 줄여야한다.

> 회귀를 더 잘 찾아내는 테스트로 개선 / 허위 경보를 발생시키지 않는 테스트로 개선 (리팩터링 내성)

허위로 울리지 않아도 버그를 찾을 수 없는 테스트는 소용 없으며, 버그를 찾을 수 있어도 소음이 많아지면 정확도는 0에 가까워진다.

#### 2.4 거짓 양성과 거짓 음성의 중요성

단기적으로는 거짓 양성이 나쁘지 않다. 프로젝트 초기에는 코드 정리를 많이 할 필요가 없으며 개발자의 기억 속에 아직 생생하기에 테스트에 잘못된 경보가 발생하더라도, 쉽게 리펙터링 할 수 있다.

그러나, 시간이 흘러 코드베이스가 복잡해짐에 따라 리팩터링의 필요성이 증대되는데, 함께 거짓 양성의 중요성도 올라간다.

> 리팩터링을 할때마다, 존재하지 않는 버그에 대한 알림이 울린다면, 테스트는 빠르게 신뢰를 잃고, 신뢰할 수 있는 피드백의 자료로 여겨지지 않는다.

즉, 프로젝트가 지속 가능한 성장을 하기 위해선, 회귀 방지 뿐만 아니라, 거짓 양성에 대해 똑같이 주의를 기울여야한다.

#### 3. 세 번째 요소와 네 번째 요소

- 빠른 피드백 (중요)
- 유지 보수성 

유지 보수성은 다음 두가지 주요 요소로 구성된다.

- 테스트가 얼마나 이해하기 쉬운가
- 테스트가 얼마나 실행하기 쉬운가 (외부 종속성에 인한 환경 세팅)

#### 4.1 이상적인 테스트를 찾아서

- 회귀 방지
- 리팩터링 내성
- 빠른 피드백
- 유지 보수

테스트의 가치는 위 네가지 특성을 곱하여 계산한다. 즉, 어떤 특성이라도 0이 되면 전체가 0이 된다.
다만 최대 점수 (모든 지표가 1)은 달성이 불가능한데, 회귀 방지, 리팩터링 내성, 빠른 피드백은 상호 배타적이기 때문이다.

> 셋 중 하나를 희생해야 나머지 둘을 최대로 할 수 있다.

`1. 극단적인 사례 End To End Test`

회귀 방지를 훌륭히 수행하며, 리팩터링 내성또한 높다.
다만, 피드백 속도가 느리다.

`2. 극단적인 사례 간단한 테스트 ex) setter / getter`

빠른 피드백과 리팩터링 내성또한 우수하나, 코드에 실수할 여지가 적기 때문에, 회귀를 나타내지 않을 것이다.

`3. 극단적인 사례 깨지기 쉬운 테스트 ex) 세부 구현 확인`

빠른 피드백 / 회귀 방지가 될 수 있으나, 리팩터링 내성 (거짓 양성)이 증가한다.

`결론`

앞서 사례로 알 수 있듯, 세가지 특성 중 한가지를 희생해야만 두가지를 극대화 할 수 있다.

> 유지 보수성은 End To End Test 를 제외하곤 상관 관계가 적다. (환경 설정 면에서 유지 보수성을 해침)

#### 4.2 어떤 지표를 희생해야하는가 ?

세가지 특성 중 리팩터링 내성은 포기할 수 없는데, `이진 선택`의 특성을 갖고 있기 때문이다.

> 리팩터링 내성이 있거나, 없거나 둘중 하나이다. (Test 가 약하게 깨진다거나 하는 현상은 없기에 ..)

즉, 빠른 피드백 / 회귀 방지 지표를 희생해야한다.



#### 4.3 테스트 피라미드 분해

테스트 피라미드란, 테스트 유형간의 일정한 비율을 일컫는 개념이다.

![test-pyramid](test-pyramid.jpg)

- 너비 -> 테스트의 수를 의미한다
- 높이 -> 사용자의 동작을 얼마나 유사하게 흉내내는가를 의미한다.

피라미드의 유형에 따라, 빠른 피드백과 회귀 방지 사이에서 선택을 한다.
어느 계층에서도 리팩터링 내성을 포기하지 않으며, 거짓 양성을 가능한 적게 하는 것을 목표로한다.

> 예외 조건 

1. 복잡도가 거의 없는 CRUD 작업이라면, 단위 테스트와 동합테스트의 수가 같고, End To End 가 없는 직사각형이 될 수 있다.

2. 아주 간단한 시스템일 경우, 단위 테스트가 적으며, 외부 연결을 하는 통합테스트가 더 많아 질 수 있다.

> 모든 상황에 피라미드 구조가 형성되는것은 아니다.

#### 5 블랙박스 / 화이트 박스 테스트 

- 블랙박스는 내부 구조를 몰라도 시스템의 기능을 검사 할 수 있는 테스트 방법이다.
- 화이트박스는 정반대로, 내부 작업을 검증하는 테스트 방식이다.

두 가지 모두 장/단점이 있는데, 화이트 박스는 세부구현을 확인하면서 테스트를 하기에, 많은 오류를 발견 할 수 있으나, 구현과 결합되어 깨지기 쉬운 테스트가 된다.

> 거짓 양성을 많이 내고, 리팩터링 내성이 부족하다. 

블랙 박스 테스트는 이와 정반대의 장/단점을 제공한다.

리팩터링 내성은 타협할 수 없으므로, 블랙 박스 테스트를 기본으로 선택하는 것이 좋다.

> 모든 테스트를 블랙박스로 만들고, 비즈니스 영역의 의미있는 동작을 확인하라.

단, 테스트를 분석할때는 화이트 박스 방법을 사용 할 수도 있으며, 화이트 박스 / 블랙 박스 조합이 가장 효과적이다.


#### 5장. 목과 테스트 취약성

#### 1. 테스트 대역의 유형

테스트 대역(`Test Double`) 은 모든 유형의 가짜 의존성 을 설명하는 포괄적인 용어로, 테스트를 편리하게 하기 위하여 사용된다.
테스트 대역에는 더미 , 스텁, 스파이, 목, 페이크 라는 다섯가지 종류가 있으나, 크게 목 / 스텁 두가지 유형으로 나눌 수 있다.

> 다섯 가지 변형의 차이점은 미미한 구현 세부사항이다.

`목`은 외부로 나가는 상호작용을 모방하고, 검사하는 데 도움이 된다. (SUT 가 상태를 변경하기 위한 위존성 호출)
`스텁`은 내부로 들어오는 상호 작용을 모방하는 데 도움이 된다. (SUT 가 입력 데이터를 얻기 위한 의존성 호출)

#### 2. 스텁으로 상호 작용을 검증하지 마라 

목과 스텁의 차이는 상호 작용을 검증하지 말라는 지침에서 비롯된다.
테스트에서 `거짓 양성`을 피하고, 리팩터링 내성을 향상 시키는 방법은 구현 세부 사항이 아니라, 최종 결과를 검증하는 것 뿐이다.

> stub 으로 처리한 객체에 대하여, mock 으로 호출 여부를 검증하지 마라 

최종 결과가 아닌 사항을 검증하는 관행을 `과잉 명세` 라고 부른다.

#### 3. CQS 와 Mock / Stub

목과 스텁의 개념은 명령 조회 분리 원칙과 관련이 있다.
CQS 원칙에 따르면 모든 메서드는 명령이거나 조회여야 하며, 그 둘을 혼용해서는 안된다.

`Command` -> Mock
`Query` -> Stub (멱등성 보장)

> pop 같은 함수가 있기 때문에 모든 상황에서 CQS 를 따를 순 없음

#### 3.1 식별할 수 있는 동작과 구현 세부 사항

`거짓 양성`이 있는 주요 원인은 코드의 구현 세부 사항과 결합돼 있기 때문이였다.
이러한 강결합을 피하는 방법은 코드가 생성하는 최종 결과를 검증하고, 구현 세부 사항과 테스트를 가능한 떨어뜨리는 것뿐이다.

> How 보다 What 을 더 중요시 해야한다. (묻지말고 말하라)

그렇다면, 구현 세부 사항은 무엇이며, 식별할 수 있는 동작과 어떻게 다른가 ??

#### 3.2 식별할 수 있는 동작은 공개 API와 다르다.

`식별할 수 있는 동작`과 `구현 세부 사항`은 겹치지 않는 속성으로, 코드가 시스템의 식별 할 수 있는 동작이려면, 다음 중 하나를 해야한다.

```text
1. 클라이언트가 목표를 달성하는데 도움이 되는 연산을 노출하라.
2. 클라이언트가 목표를 달성하는데 도움이 되는 상태를 노출하라.
```

> 구현 세부 사항은 이 두가지중 아무것도 하지 않는다.

코드가 식별 할 수 있는 동작인지의 여부는 해당 클라이언트가 누구인지 / 클라이언트의 `목표`가 무엇인지에 달려있다.
식별할 수 있는 동작이 되려면, 코드가 이러한 목표 중 하나에라도 직접적인 관계가 있어야한다.

> 클라이언트는 코드가 있는 위치에 따라 다른 것을 의미할 수 있다.ㅈ

이상적으로는 공개 API 는 식별할 수 있는 동작과 일치해야하며, 모든 구현 세부 사항은 클라이언트 눈에 보여선 안된다.

#### 3.3 잘 설계된 API 와 캡슐화

캡슐화는 궁극적으로 단위 테스트와 동일한 목표를 달성한다. 
구현 세부사항을 숨겨, 테스트가 대상 클래스에게 결합되지 않도록 단위 테스트를 작성하라.

#### 4. Mock 과 테스트 위약성 간의 관계 
#### 4.1 육각형 아키텍처 정의

전형적인 Application 은 Domain / Application Service 라는 두 계층으로 구성된다.
Domain 계층은 application 의 중심부 이기에, 도표의 중앙에 위치하며, 핵심 비즈니스 로직이 포함되어 있다.


![Hexagonal architecture](Hexagonal-architecture.png)

Application 계층은 Domain 계층 위에 있으며, 외부 환경과의 통신을 조정한다.  즉, Domain 과 외부 의존성 간의 작업을 조정한다.
application 과 domain 계층의 조합은 육각형을 형성하며, application 을 형성한다. 또한 다른 application 과 소통할 수 있고, 이또한  육각형으로 나타낸다.

> 육각형이라고 해서, 의존이 6개라는 의미는 아니다. 요점은 연결이 많다는 것이다.

Hexagonal architecture 의 주요 목적은 아래와 같다.

```text
1. domain 계층과 application service 계층간의 관심사 분리
2. application 내부 통신 
application 계층은 domain 계층을 바라보며, domain 계층은 application 계층에 의존되어서는 안된다. (단방향 의존성을 설정함)
domain 계층을 외부 환경에서 완전히 격리시킨다.

3. application 간의 통신 
외부 application 은 직접 domain 을 참조할 수 없으며, application 계층을 통해서만 연결된다.
```

각 Application 계층은 식별할 수 있는 동작을 나타내며, 구현 세부 사항을 포함하고 있다. Domain 계층은 Application 의 목표를 달성하는데 도움이 되는 상태 / 연산을 제공한다.
잘 설계된 API 원칙에는 프랙탈 특성이 나타난다. `전체 계층의 목표와 하위 계층의 목표가 똑같이 적용된다.`

> 일부 작은 조각이 전체와 비슷한 기하학적 형태를 의미
> 식별 할 수 있는 동작은 바깥에서 안쪽으로 흐르는데, 외부 클라이언트에게 중요한 목표는 개별 도메인 클래스에서 달성한 하위 목표로 변환된다.

API를 잘 설계하면 Test 에서도 프랙탈 구조를 갖기 시작하는데, 하나의 목표를 위해, 서로 다른 수준의 동작을 검증하는 형태를 띈다.

`Application layer Test` 해당 서비스가 외부 클라이언트에게 `큰 목표`를 제공하는지 검증
`Domain Layer Test` 큰 목표를 달성 하기 위한 하위 목표를 검증

즉, 각 테스트는 큰 목표를 달성하기 위한 작은 목표들을 검증해야하며, 그렇지 않으면 구현 세부사항과 결합되어 있다는 의미이다.

> 책에서는 도메인 전문에게 의미있는 이야기를 전달해야한다고 말한다. 


#### 4.2 모든 프로세스 외부 의존성을 목으로 해야하는 것은 아니다.

> 책에서 시스템 외부 통신 / 시스템 내부 통신에 대한 이야기를 하지만, 생략 

고전파는 시스템 외부 통신 (api간 통신)을 mock 으로 처리하라 권장하지만, 이또한 지나치다.

DB 와 같은 외부 의존성이 application 을 통해서만 접근할 수 있으면, 식별할 수 있는 동작이 아니며, 이또한 application 의 일부로 작용한다.

> DB 또한 구현 세부사항으로 인지한다. (6/7장에서 좀더 자세히 설명)

mock 은 application 의 경계를 넘나드는 상호 작용을 검증할때와, 상호작용의 부작용이 외부 환경에서 보일때만 사용해야한다.

> 내부 application (DB 등의 저장소) 호출은 mock을 사용하지 않아도 괜찮다 라는 말을 하고 싶은 듯함

#### 6장. 단위 테스트 스타일 


##### 1. 출력 기반 테스트 스타일

SUT 에 입력을 넣고, 출력을 검증하는 스타일로, 전역 / 내부 상태를 변경하지 않는 코드에만 적용 가능하다.
(SideEffect 가 없어야한다.)

##### 2. 상태 기반 테스트 스타일

함수를 호출 후, System 의 상태를 확인한다.
여기서 상태란, SUT / SUT 협력자 / 외부 의존성의 상태를 의미한다.

##### 3. 통신 기반 테스트 스타일 

Mock 을 사용해 SUT 와 협력자간의 통신을 검증한다.

단위 테스트에는 위처럼 3가지 스타일이 있으며, 하나의 테스트에 복수개(1~3개)를 사용 할 수 있다.

`고전파`는 통신 기반 테스트 보다, 상태 기반을 선호하며, `런던파`는 상태 기반보다 통신 기반 테스트를 선호한다.


##### 4대 요소와 스타일 비교

1. 회귀방지 및 피드백 속도 

회귀 방지는 테스트 실행량 / 복잡도 / 도메인 유의성으로 결정되므로, 스타일에 따른 차이가 없음.
피드백 속도 또한 차이가 미미함.

2. 리팩터링 내성 측면 

`리팩터링 중 발생하는 거짓 양성 수`

출력기반은 리팩터링 내성 측면에서 가장 우수하며, 상태기반은 구현 세부 사항과 결합 가능성이 높아 거짓 양성이 되기 쉽다.
통신 기반은 가장 취약한데, 상호 작용의 부작용이 외부에 보이는 경우에만 사용해야한다.


> 단 테스트 스타일에 상관 없이, 캡슐화를 잘 지키고 식별할 수 있는 동작에만 결합하면, 세부 사항의 결합을 최소로 줄일 수 있다. 
> (테스트 스타일에 따라 필요한 노력이 다르다.)


3. 유지보수성

- Test 를 이해하기 쉬운가 ?
- Test 를 실행하기 쉬운가 ?

Test가 크면 유지보수가 쉽지 않으며, 외부 의존성을 직접 연결하면 추가 시간이 소요되므로, 유지보수가 어렵다.

출력 기반은 상태를 바꾸지 않아, 이해하기 쉬우며 비교적 짧음
상태기반은 상태를 검증하기 때문에 출력 기반보다 어려움
통신기반은 mock chain이 있을 경우, Test 가 커지며 유지보수가 더 어려워지는 경향이 있다.

> 결론 

회귀 방지와 피드백 속도는 큰 차이가 없으나, 리팩터링 내성 / 유지보수성 에서는 출력 기반이 가장 우수한걸 알 수 있음
즉, 상태 / 통신기반을 출력 기반으로 바꾸는 노력이 필요하다.


또한 함수형 아키텍처 / 출력 기반 테스트를 사용 할 경우, 
시스템 성능 및 코드 량이 많아 질 수 있는데, 적당히 타협하여 사용해야한다.

> 모든 상황에서 출력 기반 테스트가 정답은 아니며, 상태 / 통신 기반을 섞어서 쓸 수 있다.

##### 함수형 프로그래밍 

숨은 입출력이 없는 함수로, 모든 입출력을 메서드 시그니처에 명시한다.
또한 멱등성이 보장되어야하며, 참조 투명성을 갖고 있어야한다.

> 참조 투명성이란, 함수가 외부 영향을 받지 않는 것으로, 표현식을 결과로 대체해도 프로그램이 지장이 없는 경우, 참조 투명성을 갖고 있다고 표현한다.

`숨은 입출력`이 있는 함수는 가독성이 떨어지며, Test 를 더 어렵게한다. 

> 숨은 입출력 유형

- SideEffect
- Exception
시그니처에 정의 되지 않은 출력(예외)으로, 어느 stack 에서든 발생 할 수 있다.
- 내/외부 상태 참조
DB 질의 및 비공개 변경가능 필드 참조하는 경우이다.

`함수형 프로그래밍`의 목표는 부작용을 완전히 제거하는게 아니라, 비즈니스 로직을 처리하는 코드 와 부작용을 일으키는 코드를 분리하는 것이다.

`비즈니스 로직`은 결정을 내리는 코드로, 함수형 코어 라고 말하며,
`부작용을 일으키는 코드`는 결정을 DB/Message Bus 등으로 변환하는 코드로, 가변 셸 이라 말한다.

`가변셸`이 입력을 받아, `함수형 코어`가 결정을 생성하고, 다시 셸이 결정을 부작용으로 반환하는 구조이다.

> 함수형 코어에 의사결정 코드를 몰아두고, 출력 기반 Test 를 두루 작성하며, 가변 셸 부분은 통합 테스트로 다룬다.

(개인 생각) 가변셸 부분에 로직이 많이 없을 경우, 통합테스트로 퉁칠 수 있을거 같음 (Application / Presentation Layer 도 퉁칠 수 있지 않을까?)

##### 함수형과 육각형 아키텍처 비교 

`공통점`

- 관심사 분리라는 아이디어 기반
- 의존성간의 단방향 흐름

`차이점`

- 부작용에 대한 처리
함수형 => 모든 부작용을 가변 셸에 담아냄 
육갹형 => 부작용을 도메인 계층에 제한한다. (상태를 들고 있는다.)

