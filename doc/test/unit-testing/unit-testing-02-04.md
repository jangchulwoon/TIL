```
+++ 
author = "kmplex" 
title = "unit testing (2-1)" 
date = "2022-01-15" 
description = "unit testing 2부 4장"  
series = ["unit testing"] 
categories = ["dev","test"] 
+++
```

[Unit Testing](http://www.yes24.com/Product/Goods/104084175)를 읽고 짤게 정리한 내용입니다.

## 2부 개발자에게 도움이 되는 테스트 만들기 

#### 4장. 좋은 단위 테스트의 4대 요소

1. 회귀 방지S
2. 빠른 피드백 
3. 리팩터링 내성 
4. 유지 보수성

#### 1. 회귀 방지 

코드를 수정한 후, 기능이 의도한 대로 동작하는가를 확인한다.

> 코드를 수정한 후, 기능이 의도한 대로 작동하지 않는 경우를 회귀라 한다.

코드는 자산이 아닌, 책임의 성격을 띄는데, 코드 베이스가 커질수록 잠재적인 버그에 더 많이 노출되기 때문이다.
이러한 이유로, 소프트웨어가 지속 / 향상되기 위해선 회귀에 대한 효과적인 보호가 필요하다.

회귀 방지의 지표는 아래와 같다.

- 테스트 중 실행되는 코드의 양 
- 코드 복잡도 
- 코드의 도메인 유의성 

회귀 방지 관점에서, 보일러 플레이트 코드보다, 도메인 코드를 확인하는게 더 중요하며, Framework 코드등 개발자가 작성하지 않은 외부 영역의 테스트도 필요하다.

> 회귀 방지 지표를 극대화 하려면, 테스트가 가능한 많은 코드를 실행하는 것을 목표로 해야한다.

#### 2. 리팩터링 내성 

테스트가 실패하지 않고, 기본 Application Code 를 리팩터링 할 수 있는지에 대한 척도이다.
기반 코드를 수정했을 때 기능에는 변화가 없지만, Test 가 깨지는 경우를 `거짓 양성`이라한다.
거짓 양성은 허위 경보로, 지속가능한 성장을 막는다. 

테스트가 `지속 가능한 성장`을 하기위해선회귀 없이 주기적으로 / 자유로운 리팩터링이 가능해야한다.

> 테스트의 목적은 지속성 / 향상성이다.

거짓 양성은 이를 방해하는데, `1.` 타당한 이유없이 테스트가 실패하며 `2.` 허위 경보를 발생 시켜, 테스트를 믿을 만한 안정망으로 인식하지 않는다.


#### 2.1 무엇이 거짓 양성의 원인인가 ? 

거짓 양성은 테스트 구성 방식과 직접적인 관련이 있는데, SUT 와 구현 세부사항이 많이 결합할수록 허위 경보가 더 많이 생긴다.    
즉, 테스트에서 구현 세부사항을 분리시켜야한다. 테스트를 통해 SUT가 제공하는 최종 결과를 검증하는지 확인해야한다.


```kotlin
class Message(val header: String, val body: String, val footer: String)


interface IRenderer {
    fun render(message: Message): String
}

class MessageRenderer : IRenderer {
    val subRenderers: MutableList<IRenderer>

    init {
        subRenderers = mutableListOf()
        subRenderers.add(HeaderRenderer())
    }

    override fun render(message: Message): String = subRenderers.joinToString("\n") { it.render(message) }
}

class HeaderRenderer : IRenderer {
    override fun render(message: Message): String = "header"
}

// Test 
@Test
fun messageRenderer_uses_correct_sub_renderers() {

    val sut = MessageRenderer()

    val renderer = sut.subRenderers

    // 식별할 수 있는 동작이 아닌, 세부 구현을 체크하는 테스트
    assertEquals(1, renderer.size)
    assertTrue(renderer[0] is HeaderRenderer)
}
```

리팩터링은 Application의 식별할 수 있는 동작에 영향을 주지 않으면서, 구현을 변경하는 것이다.   
위 테스트는 하위 랜더링 클래스의 구성을 변경할 경우 응답에 상관 없이 깨지며, 리팩터링 내성이 없는 TC이다.

> 식별할 수 있는 동작을 고려하지 않고, 구현만 고집할 경우 깨지기 쉬운 TC가 된다.

#### 2.2 구현 세부 사항 대신 최종 결과를 목표로 하기

거짓 양성을 없애기 위해선, 구현 세부사항과 테스트간 결합도를 낮춰야한다. 즉, 최종 결과에 초점을 맞춰 TC를 작성해야한다.
`MessageRenderer` 를 블랙박스로 취급하고, 식별 할 수 있는 동작에만 신경을 써야한다.

#### 2.3 테스트 정확도 극대화

코드 정확도와 테스트 결과에 대해서는 4가지 결과가 있을 수 있다.

|-|기능 작동 | 기능 고장 |
|------|---|---|
|테스트 통과|올바른 추론| 거짓 음성 (회귀 방지)|
|테스트 실패|거짓 양성| 올바른 추론|

테스트가 통과하고, 기본 기능이 의도한대로 동작하는 상황은 올바른 추론이다.
마찬가지로, 기능이 고장나서 테스트가 실패하는 상황도 올바른 추론이다.

그러나, 기능이 고장 났을 떄, 테스트가 성공하면 `거짓 음성` 으로 회귀 방지가 되지 않는다.
또한 기능이 올바르지만, 테스트가 실패할 경우엔 `거짓 양성` 으로 리팩터링 내성이 되지 않는다.

테스트의 정확도를 극대화 시키기 위해, 이러한 거짓 음성 / 거짓 양성을 줄여야한다.

> 회귀를 더 잘 찾아내는 테스트로 개선 / 허위 경보를 발생시키지 않는 테스트로 개선 (리팩터링 내성)

허위로 울리지 않아도 버그를 찾을 수 없는 테스트는 소용 없으며, 버그를 찾을 수 있어도 소음이 많아지면 정확도는 0에 가까워진다.

#### 2.4 거짓 양성과 거짓 음성의 중요성

단기적으로는 거짓 양성이 나쁘지 않다. 프로젝트 초기에는 코드 정리를 많이 할 필요가 없으며 개발자의 기억 속에 아직 생생하기에 테스트에 잘못된 경보가 발생하더라도, 쉽게 리펙터링 할 수 있다.

그러나, 시간이 흘러 코드베이스가 복잡해짐에 따라 리팩터링의 필요성이 증대되는데, 함께 거짓 양성의 중요성도 올라간다.

> 리팩터링을 할때마다, 존재하지 않는 버그에 대한 알림이 울린다면, 테스트는 빠르게 신뢰를 잃고, 신뢰할 수 있는 피드백의 자료로 여겨지지 않는다.

즉, 프로젝트가 지속 가능한 성장을 하기 위해선, 회귀 방지 뿐만 아니라, 거짓 양성에 대해 똑같이 주의를 기울여야한다.

#### 2.5 세 번째 요소와 네 번째 요소

- 빠른 피드백 (중요)
- 유지 보수성 

유지 보수성은 다음 두가지 주요 요소로 구성된다.

- 테스트가 얼마나 이해하기 쉬운가
- 테스트가 얼마나 실행하기 쉬운가 (외부 종속성에 인한 환경 세팅)

#### 2.6 이상적인 테스트를 찾아서

- 회귀 방지
- 리팩터링 내성
- 빠른 피드백
- 유지 보수

테스트의 가치는 위 네가지 특성을 곱하여 계산한다. 즉, 어떤 특성이라도 0이 되면 전체가 0이 된다.
다만 최대 점수 (모든 지표가 1)은 달성이 불가능한데, 회귀 방지, 리팩터링 내성, 빠른 피드백은 상호 배타적이기 때문이다.

> 셋 중 하나를 희생해야 나머지 둘을 최대로 할 수 있다.

`1. 극단적인 사례 End To End Test`

회귀 방지를 훌륭히 수행하며, 리팩터링 내성또한 높다.
다만, 피드백 속도가 느리다.

`2. 극단적인 사례 간단한 테스트 ex) setter / getter`

빠른 피드백과 리팩터링 내성또한 우수하나, 코드에 실수할 여지가 적기 때문에, 회귀를 나타내지 않을 것이다.

`3. 극단적인 사례 깨지기 쉬운 테스트 ex) 세부 구현 확인`

빠른 피드백 / 회귀 방지가 될 수 있으나, 리팩터링 내성 (거짓 양성)이 증가한다.

`결론`

앞서 사례로 알 수 있듯, 세가지 특성 중 한가지를 희생해야만 두가지를 극대화 할 수 있다.

> 유지 보수성은 End To End Test 를 제외하곤 상관 관계가 적다. (환경 설정 면에서 유지 보수성을 해침)

#### 2.7 어떤 지표를 희생해야하는가 ?

세가지 특성 중 리팩터링 내성은 포기할 수 없는데, `이진 선택`의 특성을 갖고 있기 때문이다.

> 리팩터링 내성이 있거나, 없거나 둘중 하나이다. (Test 가 약하게 깨진다거나 하는 현상은 없기에 ..)

즉, 빠른 피드백 / 회귀 방지 지표를 희생해야한다.



#### 2.8 테스트 피라미드 분해

테스트 피라미드란, 테스트 유형간의 일정한 비율을 일컫는 개념이다.

![jacoco report](test-pyramid.jpg)

- 너비 -> 테스트의 수를 의미한다
- 높이 -> 사용자의 동작을 얼마나 유사하게 흉내내는가를 의미한다.

피라미드의 유형에 따라, 빠른 피드백과 회귀 방지 사이에서 선택을 한다.
어느 계층에서도 리팩터링 내성을 포기하지 않으며, 거짓 양성을 가능한 적게 하는 것을 목표로한다.

> 예외 조건 

1. 복잡도가 거의 없는 CRUD 작업이라면, 단위 테스트와 동합테스트의 수가 같고, End To End 가 없는 직사각형이 될 수 있다.

2. 아주 간단한 시스템일 경우, 단위 테스트가 적으며, 외부 연결을 하는 통합테스트가 더 많아 질 수 있다.

> 모든 상황에 피라미드 구조가 형성되는것은 아니다.

#### 2.9 블랙박스 / 화이트 박스 테스트 

- 블랙박스는 내부 구조를 몰라도 시스템의 기능을 검사 할 수 있는 테스트 방법이다.
- 화이트박스는 정반대로, 내부 작업을 검증하는 테스트 방식이다.

두 가지 모두 장/단점이 있는데, 화이트 박스는 세부구현을 확인하면서 테스트를 하기에, 많은 오류를 발견 할 수 있으나, 구현과 결합되어 깨지기 쉬운 테스트가 된다.

> 거짓 양성을 많이 내고, 리팩터링 내성이 부족하다. 

블랙 박스 테스트는 이와 정반대의 장/단점을 제공한다.

리팩터링 내성은 타협할 수 없으므로, 블랙 박스 테스트를 기본으로 선택하는 것이 좋다.

> 모든 테스트를 블랙박스로 만들고, 비즈니스 영역의 의미있는 동작을 확인하라.

단, 테스트를 분석할때는 화이트 박스 방법을 사용 할 수도 있으며, 화이트 박스 / 블랙 박스 조합이 가장 효과적이다.









