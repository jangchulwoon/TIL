```
+++
author = "kmplex"
title = "만들면서 배우는 클린아키텍처 1일차"
date = "2022-10-23"
description = "만들면서 배우는 클린 아키텍처 1장 ~ 3장"
series = ["clean architecture"]
categories = ["study","ddd"]
+++
```

## 01. 계층형 아키텍처의 문제는 무엇일까 ?

상위 수준 관점에서 일반적인 3계층 아키텍처를 표현한 그림이다.

![계층형 아키텍처](./layered-architecture.png)

1) 웹 계층에서는 요청을 받아 도메인 혹은 비즈니스 계층에 있는 서비스로 요청을 보낸다.
2) 서비스에서는 필요한 비즈니스 로직을 수행하고, 도메인 엔티티의 현재 상태를 조회하거나 변경하기 위해 영속성 계층의 컴포넌트를 호출한다.

잘 만들어진 계층형 아키텍처는 선택의 폭을 넓히고 변화하는 요구사항과 외부 요인에 빠르게 적응 할 수 있게 해준다.
또한 계층을 잘 이해하고 구성한다면 웹 계층이나 영속성 계층에 독립적으로 도메인 로직을 작성 할 수 있다.

`그렇다면 무엇이 문제인가?`

#### 계층형 아케턱처는 데이터베이스 주도 설계를 유도한다.

전통적인 계층형 아키텍처의 토대는 데이터 베이스이다.
웹 계층은 도메인 계층에 의존하고, 도메인 계층은 영속성 계층에 의존하기에, 자연스레 데이터 베이스에 의존하게 된다.

모든 것이 영속성 계층을 토대로 만들어지는데, 이는 다양한 이유로 문제를 초래한다.

우리가 만드는 대부분의 애플리케이션의 목적은, 비즈니스를 관장하는 규칙 / 정책을 반영한 모델을 만들어서 사용자가 이러한 규칙과 정책을 더욱 편리하게 활용 할 수 있게 한다.    
즉, 비즈니스를 이끄는 것은 상태가 아닌 행동이다.

그렇다면 우리는 왜 데이터 베이스를 토대로 아키텍처를 만드는가 ?

> 그동안 만들어본 애플리케이션의 유스케이스를 떠올려보자. 아마 데이터베이스의 구조를 먼저 생각하고 이를 토대로 도메인 로직을 구현 했을 것이다.

이는 전통적인 계층형 아키텍처에서는 합리적인 방법이나, 비즈니스 관점에서는 전혀 맞지 않는 방법이다.
다른 무엇보다 도메인 로직을 먼저 만들고 이를 토대로 영속성 계층과 웹 계층을 만들어야한다.

데이터 베이스 중심적인 아키텍처가 만들어지는 가장 큰 원인은 ORM 프레임워크를 사용하기 때문이다.
ORM 프레임워크와 계층형 아키텍처를 결합하면, 비즈니스 규칙을 영속성 관점과 섞고 싶은 유횩을 쉽게 받는다.

하지만 이러한 설계는 영속성 계층과 도메인 계층 사이에 강한 결합이 생긴다.
서비스는 영속성 모델을 비즈니스 모델처럼 사용하게 되고, 이로 인해 도메인 로직뿐 아니라 영속성 계층과 관련된 작업들을 해야만한다.

`개인적인 생각`   
영속성을 기준으로 설계가 되는 이유는 DB call 혹은 transaction 을 짧게 가져가기 위함이라고 생각한다.
엄청 복잡한 스펙이 아닌 이상, api 의 응답속도는 DB의 읽기 지연 혹은 쓰기 지연으로 발생하는데, 하나의 도메인에 2개 이상의 table 이 연관 될 경우 읽기 / 쓰기 시 그만큼 속도가 늘어날 것이다.

(이 부분은 내가 생각이 갇혀있어서 그럴 수 있음) 또한, 엔티티와 테이블의 설계가 다를 경우, 구조파악을 하기 어려울거 같다는 생각도 든다.

> 2개 이상의 table 로 1개의 Entity(?) / Domain (이)가 구성된다면, 유지보수 시 상태를 추적하기 어렵지 않을까?

스펙이 복잡해짐에 따라, 도메인 모델과 테이블이 유사해야된다고 생각한다.

물론 책의 내용도 반드시 도메인과 영속성 모델이 반드시 달라야한다. 라고 말하는건 아니다.

#### 지름길을 택하기 쉬워진다.

전통적인 계층형 아키텍처에서 전체적으로 적용되는 규칙은, 특정 계층에서 같은 계층에 있는 컴포넌트나 아래에 있는 계층에만 접근 가능하다는 것이다.
개발 팀 내에서 합의한 다른 규칙들이 있을 수 있고, 그중 일부는 개발 도구를 이용해 강제화 했을지 모르지만, 계층형 아키텍처 자체는 위 규칙외 다른 규칙을 강제하진 않는다.

만약, 상위 계층에 위치한 컴포넌트에 접근해야한다면 간단하게 컴포넌트를 계층 아래로 내려버리면된다.

딱 한번 이렇게 하는건 괜찮지만, 마감이 다가오거나 전례가 있을 경우 점점 아키텍처가 이상해 질 수 있다. ~~깨진 창문 이론~~

![계층형 아키텍처](./layered-architecture-pollution.png)

결국 수년에 걸친 개발과 유지보수로 위 그림처럼 될 확률이 높다.
이러한 지름길 모드를 끄고 싶다면, 아키텍처 규칙을 강제해야한다.    
`강제`란 해당 규칙이 깨졌을 때, 빌드가 실패하도록 만드는 규칙이다.

#### 테스트하기 어려워진다.

계층형 아키텍처를 사용 할 때, 일반적으로 나타나는 변화는 계층을 건너 뛰는 것이다.
엔티티의 필드를 하나만 조작하면 되는 경우, 웹 계층에서 바로 영속성 계층에 접근하면, 도메인 계층을 건드릴 필요가 없지 않을까?

다시 말하자면, 처음 몇번은 괜찮다. 다만 이러한 일이 자주 일어난다면, 두가지 문제점이 생긴다.

1) 도메인 로직을 웹 계층에 구현해버린다.
2) 웹 계층 테스트에서 영속성 계층도 mocking 해야한다.

#### 유스케이스를 숨긴다.

개발자는 새로운 코드를 짜는 것보다, 기존 코드를 바꾸는데 더 많은 시간을 쓴다.
즉, 기능을 추가하거나 변경할 적절한 위츠를 찾는 일이 빈번하고 때문에 아키텍처는 코드를 빠르게 탐색하는데 도움이 돼야한다.

앞서 이야기 했듯, 계층형 아키텍처에서는 도메인 로직이 여러 계층에 걸쳐 흩어지기 쉽다.
유스케이스가 간단해서, 도메인 계층을 생략한다면 웹 계층에 존재 할 수 도 있고, 영속성 계층으로 컴포넌트를 내렸다면 영속성 계층에 도메인 코드가 존재할 수도 있다.

이럴 경우, 새로운 기능을 추가할 적당한 위치를 찾는 일은 어려워진다.

또한 특정 도메인 서비스가 비대해져, 여러개의 유스케이스를 담당하는 아주 넓은 서비스가 만들어지기도 한다.
넓은 서비스는 영속성 계층에 많은 의존성을 갖게 되고, 다시 웹 레이어의 많은 컴포넌트가 이 서비스에 의존하게 된다.

서비스를 테스트하기가 점점 어려워지며, 작업해야할 유스케이스를 책임지는 서비스도 찾기 어려워진다.

고도로 특화된 좁은 도메인 서비스가 유스케이스 하나씩만 담당하게 된다면, 작업들이 꽤나 수월해진다.

#### 동시 작업이 어려워진다.

`지연되는 소프트웨어 프로젝트에 인력을 더하는 것은 개발을 늦출 뿐이다. (맨먼스 미신)`

계층형 아키텍처는 이런 측면에서 그다지 도움이 되지 않는다.
3명의 개발자가 한가지 기능을 개발 할때, 계층 단위로 작업을 쪼개서 분배하기도 어려우며, 코드에 넓은 서비스가 있다면, 서로 다른 기능을 동시에 작업하기 더욱 어려워지며, 같은 서비스를 동시에 작업하는 상황이 발생하게된다.
이는 병햡 충돌로 추가 시간을 소모하게 된다.

#### 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까 ?

과거 계층형 아키텍처를 만들어봤다면 해당 단점외에 다른 단점들도 떠오를 것이다.
올바르게 구축하고, 몇가지 규칙들이 적용된 계층형 아키텍처는 개발하기 쉬우며 코드를 쉽게 변경 / 유지보수 할 수 있다.

그러나 앞서 설명했듯, 계층형 아키텍처는 많은 것들이 잘못된 방향으로 흘러가도록 용인한다.
엄격한 자기 훈련 없인 시간이 지날 수록 프로젝트의 유지보수성이 저하되는데, 계층형 아키텍처의 함정을 염두면서 더 유지보수 하기 쉬운 솔루션을 만들어야한다.

어떤 아키텍처 스타일을 사용하든 단점은 분명히 존재하며, 지속적인 자기 훈련을 통해 유지보수성을 높여나가야한다.