```
+++
author = "kmplex"
title = "만들면서 배우는 클린아키텍처 2일차"
date = "2022-10-26"
description = "만들면서 배우는 클린 아키텍처 4장"
series = ["clean architecture"]
categories = ["study","ddd"]
+++
```

## 유스케이스 구현하기

#### 유스케이스 둘러보기

일반적으로 유스케이스는 다음과 같은 단계를 따른다.

```text
01. 입력을 받는다.
02. 비즈니스 규칙을 검증한다.
03. 모델 상태를 조작한다.
04. 출력을 반환한다.
```

유스케이스는 인커밍 어댑터로부터 입력을 받는다.

> 유스케이스 코드가 도메인 로직에만 신경 써야하고, 입력 유효성 검증으로 오염되면 안되기때문에 입력 유효성 검증은 다른 곳에서 처리되어야한다.

다만, 유스케이스는 비즈니스 규칙을 검증할 책임이 있으며, 도메인 엔티티와 이 책임을 공유한다. 

비즈니스 규칙을 충족하면, 유스케이스는 입력을 기반으로 어떤 방법으로든 모델의 상태를 변경한다.
필요에 따라 유스케이스는 다른 아웃고잉 어댑터를 호출 할 수 있으며, 해당 출력값을 유스케이스를 호출한 어댑터로 반환한다.

`개인적인 생각`

port adapter 로 너무 인터페이스가 많아지는 느낌. 
조금 더 느슨하게 구조를 가져가도 좋을거 같다는 생각이 든다. 

> 어떤 의도 / 개념에서 해당 구조를 가져가는지만 이해하고 넘어가도 좋을거 같음.

#### 입력 유효성 검증 

유스케이스 클래스가 아니라면, 어디에서 입력 유효성을 검증해야할까? 

`입력 모델`이 이 문제를 다루도록 해보자.  

> port 로 데이터를 넘길때, Dto 객체를 만들어서 그 안에서 값에 대한 유효성 검증을 하면 된다.

spring 에서는 valid 라는 annotation 으로 입력 유효성 검증을 할 수 있음.

#### 생성자의 힘 

builder 를 굳이 쓰지 않아도 된다는 내용.

#### 유스케이스마다 다른 입력 모델 

add / update 시 데이터가 유사하기 때문에 입력 모델을 동일하게 가져갈 수 있으나,  엄연히 다른 유스케이스로 서로 다른 유효성 검사를 필요로하게 된다.
불필요한 결합이 생기기 때문에 불편하더라도, 다른 입력모델을 사용해야한다. 

#### 비즈니스 규칙 검증하기

언제 입력 유효성을 검증하고, 언제 비즈니스 규칙을 검증해야할까 ? 

둘 사이의 아주 실용적인 구분점은, 비즈니스 규칙을 검증하는 것은 도메인 모델의 현재 상태에 접근해야하는 반면,
 입력 유효성 검증은 그럴 필요가 없다는 것이다. 

> 입력 유효성은 @NotNull 과 같이 선언적으로 구현할 수 있지만, 비즈니스 규칙은 조금 더 맥락이 필요하다.

비즈니스 내에서 의미 있는 컬럼은 입력 유효성이 아닌, 비즈니스 규칙으로 다뤄야한다고 주장할 수도 있다.
하지만, 앞에서 보여준 구분법은 추후 로직이 어디에 있는지 더 쉽게 찾는데 도움이 된다. 

> 단순 컬럼은 입력 유효성으로, 상태를 조회하는 것은 비즈니스 규칙으로 일관되게 다룬다면 추후 쉽게 찾을 수 있다.

그렇다면 비즈니스 규칙 검증은 어떻게 해야할까 ?  가장 좋은 방법은 도메인 엔티티 안에 넣는 것이다.

#### 풍부한 도메인 모델 vs 빈약한 도메인 모델 

풍부한 도메인 모델은 코어에 있는 엔티티에서 가능한 많은 도메인 로직이 구현된다.
이 케이스에서 유스케이스는 도메인 모델의 진입점으로 동작하며, 많은 비즈니스 규칙이 유스케이스 구현체 대신 엔티티에 위치하게 된다.

빈약한 도메인 모델에서는 엔티티 자체가 굉장히 얇다.

일반적으로 getter / setter 메서드만 포함하고 어떤 도메인 로직도 갖고 있지 않다.
이말은 즉, 도메인 로직이 유스케이스에 구현되어 있다는 것으로 풍부함이 엔티티가 아닌, 유스케이스에 존재하게 된다.

> 각자 필요에 맞는 스타일을 자유롭게 선택하는게 좋다.


`개인적인 생각`

나는 대체로 풍부한 모델을 선호하지만 ..  
유스케이스를 세분화하여 분리한다면, 빈약한 모델이 좋을 것같고 세분화 하지 않는다면 풍부한 도메인 모델이 좋을거 같다. 

#### 유스케이스마다 다른 출력 모델

입력과 비슷하게 출력도 가능하면 각 유스케이스에 맞게 구체적일 수록 좋다.
출력은 호출자에게 꼭 필요한 데이터만 들고 있어야한다.

입력과 마찬가지로, 출력 또한 모델을 공유하게되면 유스케이스들도 강하게 결합된다. 

#### 읽기 전용 유스케이스는 어떨까 ?

UI에 잔액을 표시해야한다고 할때, 이를 위한 새로운 유스케이스를 구현해야할까?

코어 관점에서 간단한 데이터 쿼리일 경우, 프로젝트 맥락에서 유스케이스로 간주되지 않는다면 쿼리로 구현할 수 있다. (`CQRS` 개념과 유사)

`개인적인 생각`

단순히 select 만을 하는 api 라면, 쿼리 형태로 작성하고 차츰 쿼리에 역할이 부여될 경우 유스케이스로 진화시키는게 옳은거 같다.
여기서 쿼리란, service 계층을 유스케이스로 이름짓는게 아닌, 쿼리 형태로 이름 짓는 것을 의미한다.

4장은 유지보수 가능한 소프트웨어를 만드는 방법으로 아래 2가지를 제시했다.
```text
1) 입력 모델과 출력 모델에 대하여, 각 유스케이스 간의 결합도를 떨어뜨리기 위한 방법(`모델 분리` )
2) 유효성 검증 로직을 어디에 둬야할지에 대한 이야기이다.
```

## 5장 웹 어댑터 구현하기

#### 의존성 역전 

앞서 설명했듯, port-adapter pattern 은 의존성 역전 원칙을 적용한다.

> controller 는 port interface 를 호출 하고, 서비스(유스케이스)는 port 를 상속한다.

#### 웹 어댑터의 책임

웹 어댑터의 책임은 아래와 같다.

1) Client의 입력 모델을 유스케이스의 입력 모델로 변환 한다.
2) 유스케이스의 출력을 Http 응답으로 전달한다.

위와 같은 역할을 애플리케이션 계층으로 침투되면 안되며, 반대로 코어의 역할이 웹 어댑터에 들어가 있으면 안된다.

#### 컨트롤러 나누기 

컨트롤러는 적은것보단 많이 쪼개는게 낫다. 

각 컨트롤러가 가능한 좁고 다른 컨트롤러와는 가능한 적게 공유하는 웹 어댑터 조각을 구현해야한다.

코드가 길 수록, 파악하기 어려워지며 테스트 코드 또한 작성하기 어렵고 길어진다.
뿐만 아니라, 단일 컨트롤러 안에 모든 구현사항을 몰아둘 경우, 각 시나리오가 모델을 공유하게 될 여지가 있다.

`개인적인 생각`

책에서는 계속 불편함을 통해 사람이 실수 혹은 지름길로 가지 않게 강제하고 있다.
책을 읽는 내내, `굳이 이렇게 까지 해야돼?` 라는 생각이 들지만, `이렇게 까지 하지 않으면 지름길로 갈 수 있어` 라고 책이 말하는 듯함.

> 개인적으로 납득 가능한 수준은  CQRS 로 Controller 를 나누는 것.

이 챕터에서 말하고 싶은 내용은 아래와 같음.

1) 컨트롤러 layer 에 도메인 로직이 담기면 안된다. 
2) 컨트롤러를 잘게 쪼갬으로, 테스트가 용이하게 / 시나리오간 모델을 공유하지 않게 예방해야한다. 
